
import numpy as  np
import matplotlib.cm as cm
import torch
import torch.nn as nn
from   torch.nn import Parameter

from copy  import copy, deepcopy
from .shapes            import Curve
from .data_attachment   import _data_attachment
from .geodesic_shooting import _Hqp, _HamiltonianShooting, _HamiltonianCarrying
from .input_output      import save_info, save_momentum, new_grid

class GeodesicMatching(nn.Module) :
    """
    """
    def __init__(self, template, weights=None) :
        "Defines the parameters of the model."
        super(GeodesicMatching, self).__init__()
        
        self.template = template
        if weights is None : self.weights  = self.template.points_weights()
        self.p0       = Parameter(torch.zeros_like(template.points.data))

    def forward(self, params_def) :
        """
        Shoots.
        """
        q1        = copy(self.template)
        q1.points = _HamiltonianShooting(q1.points, self.p0, params_def, self.weights)[0]
        return q1
    
    def cost(self, params, target, info=False) :
        """
        Shoots + Computes the cost
        """
        # Compute the squared length of the geodesic associated to self.p0,
        # i.e. the squared geodesic distance between the template and the model:
        reg       = _Hqp(self.template.points, self.p0, params["deformation_model"], self.weights)

        # Compute the data attachment term between the shooted model and the target,
        # which can be identified with a "squared distance" from the model to the target.
        self.last_model =     self.forward(                params["deformation_model"]      )
        self.last_model.points.retain_grad()
        cost,info = _data_attachment( self.last_model, target, params["data_attachment"],  info )

        # The final cost is a linear combination of the previous two terms:
        # the optimal model can be thought of as a "pseudo-Fr√©chet" mean
        # between the template and the target.
        cost      = params["weight_regularization"]  * reg \
                  + params["weight_data_attachment"] * cost
        return cost, info, self.last_model



    # Display/Output routines -----------------------------------------------------------------------

    def diffeomorphism_info(self, params, trajectory=False) :
        """
        Outputs a Curve object, encoding a uniform grid carried along by the model.
        This routine helps us to visualize the underlying diffeomorphism of the ambient space
        generated by our LDDMM-like toolbox.
        """
        # Create a new grid:
        dim         = self.template.points.size(1)
        par_plot    =   params.get("display",    {})
        grid_ticks  = par_plot.get("grid_ticks", ((0,1,11),)*dim)
        grid        = new_grid(grid_ticks)

        # "Shoot" the grid, alongside the template. We may as well store the whole
        # trajectory, and only output the final state if trajectory==False
        qts, pts, gts = _HamiltonianCarrying(self.template.points, self.p0, grid.points, 
                                             params["deformation_model"], self.weights, trajectory=True)

        # Wrap the torch variables into Shape objects (with connectivity matrix, etc.):
        Qts = [] ; Gts = []
        for (qt,gt) in zip(qts, gts) :
            Qt = copy(self.template) ; Qt.points = qt ; Qts.append(Qt) 
            Gt = copy(grid)          ; Gt.points = gt ; Gts.append(Gt)

        if trajectory : return Qts,     pts,     Gts
        else :          return Qts[-1], pts[-1], Gts[-1]  # only return the final state

    def plot(self, axis, params, info=None, target=None) :
        """
        Displays the model+target in a matplotlib figure.

        Args:
            axis (matplotlib axis handle) : the output canva
            params (dict)                 : the model's parameters
            target (Shape, optional)      : the target to which the model was fitted
        """

        attach_type = params["data_attachment"]["formula"]
        par_plot = params.get("display", {})

        model, p1, grid = self.diffeomorphism_info(params)

        # Plot a uniform grid, carried around by the deformation:
        if par_plot.get("grid",     True) :
            color       = par_plot.get("grid_color",    (.8,.8,.8))
            lw          = par_plot.get("grid_linewidth", 1 )
            grid.plot(axis, color=color, linewidth=lw)

        # Display the template:
        if par_plot.get("template", True) :
            color = par_plot.get("template_color",    "b")
            lw    = par_plot.get("template_linewidth", 2 )
            self.template.plot(axis, color=color, linewidth=lw)

        # Display the transport plan:
        if   par_plot.get("info", True) and isinstance(info, Curve) :
            color = par_plot.get("info_color",    (.8, .9, 1., .3))
            lw    = par_plot.get("info_linewidth", 1 )
            info.plot(axis, color=color, linewidth=lw)

        # Display the two transport plans, from Mu to Nu and vice-versa:
        if   par_plot.get("info", True) and isinstance(info, tuple) \
            and isinstance(info[0], Curve) and isinstance(info[1], Curve)  :
            color_mu2nu = par_plot.get("info_color_a",    (.8, .4, .4, .15))
            color_nu2mu = par_plot.get("info_color_b",    (.4, .4, .8, .15))
            lw          = par_plot.get("info_linewidth", 1 )
            info[0].plot(axis, color=color_mu2nu, linewidth=lw)
            info[1].plot(axis, color=color_nu2mu, linewidth=lw)

        # Display the kernel heatmap:
        elif par_plot.get("info", True) and attach_type == "kernel" :
            coords = params.get("data_attachment", {}).get("kernel_heatmap_range", (-2,2,100))
            scale_attach = params["display"].get("kernel_heatmap_max", None)
            if scale_attach  is None :
                scale_attach = 1.2 * np.amax( np.abs(info[:]) )
            axis.imshow(-info, interpolation='bilinear', origin='lower', 
                        vmin = -scale_attach, vmax = scale_attach, cmap=cm.RdBu, 
                        extent=(coords[0],coords[1],coords[0],coords[1])) 

        # Display the log-kernel heatmap using a contour plot:
        elif par_plot.get("info", True) and \
            attach_type in ("likelihood_source_wrt_target", "likelihood_target_wrt_source") :
            
            scale_attach = np.amax( np.abs(info[:]) )
            levels = np.linspace(-scale_attach, scale_attach, 40)

            coords = params.get("data_attachment", {}).get("kernel_heatmap_range", (-2,2,100))
            axis.contour(info, origin='lower', linewidths = 1., colors = "#646464",
                        levels = levels,
                        extent=(coords[0],coords[1],coords[0],coords[1])) 

        elif par_plot.get("info", True) and attach_type == "likelihood_symmetric" :

            scale_attach = max( np.amax( np.abs( info[0][:]) ), np.amax( np.abs( info[1][:]) ))
            levels = np.linspace(-scale_attach, scale_attach, 40)

            coords = params.get("data_attachment", {}).get("kernel_heatmap_range", (-2,2,100))
            axis.contour(info[0], origin='lower', linewidths = 1., colors = "#6464C8",
                        levels = levels,
                        extent=(coords[0],coords[1],coords[0],coords[1])) 
            axis.contour(info[1], origin='lower', linewidths = 1., colors = "#C86464",
                        levels = levels,
                        extent=(coords[0],coords[1],coords[0],coords[1])) 

        # Display the target:
        if par_plot.get("target",   True) :
            color = par_plot.get("target_color",    (.76, .29, 1.))
            lw    = par_plot.get("target_linewidth", 2 )
            target.plot(axis, color=color, linewidth=lw)

        # Display the model:
        if par_plot.get("model",    True) :
            color = par_plot.get("model_color",    "rainbow")
            lw    = par_plot.get("model_linewidth", 2 )
            model.plot(axis, color=color, linewidth=lw)

        # Display the gradient field driving the model:
        if par_plot.get("model_gradient", True) :
            color = par_plot.get("model_gradient_color",    "k")
            lw    = par_plot.get("model_gradient_linewidth", .004 )
            scale = par_plot.get("model_gradient_scale", 1. )
            points =   self.last_model.points.data.cpu().numpy()
            grads  = - self.last_model.points.grad.data.cpu().numpy()

            if scale < 0. :
                median_length = np.median(np.sqrt(np.sum(grads**2, 1)))
                scale = -scale *median_length #/ (.001 + median_length)
            axis.quiver( points[:,0], points[:,1], grads[:,0], grads[:,1] , 
                         angles='xy', scale_units='xy', scale=scale, width=lw, 
                         units = 'width', zorder = 2.)
        
    
    def save(self, params, target, info=None, it=None, model=None) :
        
        par_save =   params.get("save", {})
        prefix   = par_save.get("output_directory", "output/")

        # Save the template, model and target (in case the latter changes with iterations)
        if par_save.get("template", True) : self.template.save( prefix + 'templates/template_'+str(it))
        if par_save.get("model",    True) :         model.save( prefix + 'models/model_'      +str(it))
        if par_save.get("target",   True) :        target.save( prefix + 'targets/target_'    +str(it))

        # Save the Shooting momentum
        if par_save.get("momentum", True) : save_momentum(      prefix + 'momenta/momentum_'  +str(it),
                                                                self.template.points, self.p0, self.weights )
        
        # Save the Optimal Transport plan, etc.
        if par_save.get("info",     True) : save_info(          prefix + 'infos/info_'        +str(it), 
                                                                model, target, info, params["data_attachment"] )

        # Save the "Shooting movie". As this is quite expensive, it is disabled by default
        if par_save.get("movie",   False) :
            Qts, Pts, Gts = self.diffeomorphism_info(params, trajectory=True)
            prefix_mov    = prefix + 'movies/iteration_'+str(it)+'/'
            for (t,(Qt,Pt,Gt)) in enumerate(zip(Qts,Pts,Gts)) :
                Qt.save( prefix_mov + 'models/model_'    +str(t))
                Pt.save( prefix_mov + 'momenta/momentum_'+str(t))
                Gt.save( prefix_mov + 'grids/grid_'      +str(t))
