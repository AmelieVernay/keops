
import torch
import torch.nn as nn
from   torch.nn import Parameter

from copy  import copy, deepcopy
from .data_attachment   import _data_attachment
from .geodesic_shooting import _Hqp, _HamiltonianShooting, _HamiltonianCarrying
from .input_output      import save_info, save_momentum, new_grid

class GeodesicMatching(nn.Module) :
    """
    """
    def __init__(self, template, weights=None) :
        "Defines the parameters of the model."
        super(GeodesicMatching, self).__init__()
        
        self.template = template
        self.weights  = weights
        self.p0       = Parameter(torch.zeros_like(template.points.data))

    def forward(self, params_def) :
        """
        Shoots.
        """
        model        = copy(self.template)
        model.points = _HamiltonianShooting(model.points, self.p0, params_def, self.weights)[0]
        return model
    
    def cost(self, params, target, info=False) :
        """
        Shoots + Computes the cost
        """
        # Compute the squared length of the geodesic associated to self.p0,
        # i.e. the squared geodesic distance between the template and the model:
        reg       = _Hqp(self.template.points, self.p0, params["deformation_model"], self.weights)

        # Compute the data attachment term between the shooted model and the target,
        # which can be identified with a "squared distance" from the model to the target.
        model     =     self.forward(                params["deformation_model"]      )
        cost,info = _data_attachment( model, target, params["data_attachment"],  info )

        # The final cost is a linear combination of the previous two terms:
        # the optimal model can be thought of as a "pseudo-Fr√©chet" mean
        # between the template and the target.
        cost      = params["weight_regularization"]  * reg \
                  + params["weight_data_attachment"] * cost
        return cost, info, model



    # Display/Output routines -----------------------------------------------------------------------

    def diffeomorphism_info(self, params, trajectory=False) :
        """
        Outputs a Curve object, encoding a uniform grid carried along by the model.
        This routine helps us to visualize the underlying diffeomorphism of the ambient space
        generated by our LDDMM-like toolbox.
        """
        # Create a new grid:
        dim         = self.template.points.size(1)
        par_plot    =   params.get("display",    {})
        grid_ticks  = par_plot.get("grid_ticks", ((-1,1,11),)*dim)
        grid        = new_grid(grid_ticks)

        # "Shoot" the grid, alongside the template. We may as well store the whole
        # trajectory, and only output the final state if trajectory==False
        qts, pts, gts = _HamiltonianCarrying(self.template.points, self.p0, grid.points, 
                                             params["deformation_model"], self.weights, trajectory=True)

        # Wrap the torch variables into Shape objects (with connectivity matrix, etc.):
        Qts = [] ; Gts = []
        for (qt,gt) in zip(qts, gts) :
            Qt = copy(self.template) ; Qt.points = qt ; Qts.append(Qt) 
            Gt = copy(grid)          ; Gt.points = gt ; Gts.append(Gt)

        if trajectory : return Qts,     pts,     Gts
        else :          return Qts[-1], pts[-1], Gts[-1]  # only return the final state

    def plot(self, axis, params, target=None) :
        """
        Displays the model+target in a matplotlib figure.

        Args:
            axis (matplotlib axis handle) : the output canva
            params (dict)                 : the model's parameters
            target (Shape, optional)      : the target to which the model was fitted
        """

        par_plot = params.get("display", {})

        model, p1, grid = self.diffeomorphism_info(params)

        # Plot a uniform grid, carried around by the deformation:
        if par_plot.get("grid",     True) :
            color       = par_plot.get("grid_color",    (.8,.8,.8))
            lw          = par_plot.get("grid_linewidth", 1 )
            grid.plot(axis, color=color, linewidth=lw)

        # Display the template:
        if par_plot.get("template", True) :
            color = par_plot.get("template_color",    "b")
            lw    = par_plot.get("template_linewidth", 2 )
            self.template.plot(axis, color=color, linewidth=lw)

        # Display the target:
        if par_plot.get("target",   True) :
            color = par_plot.get("target_color",    (.76, .29, 1.))
            lw    = par_plot.get("target_linewidth", 2 )
            target.plot(axis, color=color, linewidth=lw)

        # Display the model:
        if par_plot.get("model",    True) :
            color = par_plot.get("model_color",    "rainbow")
            lw    = par_plot.get("model_linewidth", 2 )
            model.plot(axis, color=color, linewidth=lw)
        
    
    def save(self, params, target, it=None) :
        
        par_save =   params.get("save", {})
        prefix   = par_save.get("output_directory", "output/")
        cost,info,model = self.cost(params, target, info=True)

        # Save the template, model and target (in case the latter changes with iterations)
        if par_save.get("template", True) : self.template.save( prefix + 'templates/template_'+str(it))
        if par_save.get("model",    True) :         model.save( prefix + 'models/model_'      +str(it))
        if par_save.get("target",   True) :        target.save( prefix + 'targets/target_'    +str(it))

        # Save the Shooting momentum
        if par_save.get("momentum", True) : save_momentum(      prefix + 'momenta/momentum_'  +str(it),
                                                                self.template.points, self.p0, self.weights )
        
        # Save the Optimal Transport plan, etc.
        if par_save.get("info",     True) : save_info(          prefix + 'infos/info_'        +str(it), 
                                                                model, target, info, params["data_attachment"] )

        # Save the "Shooting movie". As this is quite expensive, it is disabled by default
        if par_save.get("movie",   False) :
            Qts, Pts, Gts = self.diffeomorphism_info(params, trajectory=True)
            prefix_mov    = prefix + 'movies/iteration_'+str(it)+'/'
            for (t,(Qt,Pt,Gt)) in enumerate(zip(Qts,Pts,Gts)) :
                Qt.save( prefix_mov + 'models/model_'    +str(t))
                Pt.save( prefix_mov + 'momenta/momentum_'+str(t))
                Gt.save( prefix_mov + 'grids/grid_'      +str(t))
