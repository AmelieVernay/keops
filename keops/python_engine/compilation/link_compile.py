import os, time
from ctypes import create_string_buffer, CDLL

from keops.python_engine.utils.code_gen_utils import get_hash_name
from keops.python_engine.config import build_path

class link_compile:
    
    # base class for compiling the map_reduce schemes and
    # providing the dll to KeOps bindings.
    
    def __init__(self, use_jit):
        # N.B. Here self is assumed to be populated by the __init__ of one of the MapReduce classes
        
        # use_jit : if True, use JIT compiling mode
        self.use_jit = use_jit
        # we create the hash string id corresponding to all parameters, e.g. 7b9a611f7e
        self.gencode_filename = get_hash_name(type(self), 
                                                self.red_formula_string, 
                                                self.aliases, 
                                                self.nargs, 
                                                self.dtype, 
                                                self.dtypeacc, 
                                                self.sum_scheme_string)
        
        # info_file is the name of the file that will contain some meta-information required by the bindings, e.g. 7b9a611f7e.nfo
        self.info_file = self.gencode_file + ".nfo"      
        
        if use_jit:
            # these are used for JIT compiling mode
            # low_level_code_file is filename of low level code generated by the JIT compiler, e.g. 7b9a611f7e.ptx for Cuda
            self.low_level_code_file = (build_path + os.path.sep + self.gencode_filename + "." + self.low_level_code_extension).encode('utf-8')
            self.my_c_dll = CDLL(self.jit_binary)
        else:
            # these are used for command line compiling mode
            # gencode_file is the name of the source file to be created and then compiled, e.g. 7b9a611f7e.cpp or 7b9a611f7e.cu
            self.gencode_file = build_path + os.path.sep + self.gencode_filename + "." + self.source_code_extension
            # dllname is the name of the binary dll obtained after compilation, e.g. 7b9a611f7e.so
            self.dllname = self.gencode_file + ".so"  
            # compile command string to obtain the dll, e.g. "g++ 7b9a611f7e.cpp -shared -fPIC -O3 -flto -o 7b9a611f7e.so"
            self.compile_command = f"{self.compiler} {' '.join(self.compile_options)} {self.gencode_file} -o {self.dllname}"
    
    def save_info(self):
        # create info_file to save some parameters : dim (dimension of output vectors), 
        #                                            tagI (O or 1, reduction over i or j indices), 
        #                                            dimy (sum of dimensions of j-indexed vectors)
        f = open(self.info_file,"w")
        f.write(f"dim={self.dim}\ntagI={self.tagI}\ndimy={self.dimy}")
        f.close()
    
    def read_info(self):
        # read info_file to retreive dim, tagI, dimy
        f = open(self.info_file,"r")
        string = f.read()
        f.close()
        tmp = string.split("\n")
        if len(tmp)!= 3:
            raise ValueError("incorrect info file")
        tmp_dim, tmp_tag, tmp_dimy = tmp[0].split("="), tmp[1].split("="), tmp[2].split("=")
        if len(tmp_dim)!=2 or tmp_dim[0]!="dim" or len(tmp_tag)!=2 or tmp_tag[0]!="tagI" or len(tmp_dimy)!=2 or tmp_dimy[0]!="dimy":
            raise ValueError("incorrect info file")
        self.dim = eval(tmp_dim[1])
        self.tagI = eval(tmp_tag[1])
        self.dimy = eval(tmp_dimy[1])
        
    def write_code(self):
        # write the generated code in the source file ; this is used as a subfunction of compile_code
        f = open(self.gencode_file,"w")
        f.write(self.code)
        f.close()
        
    def compile_code(self):   
        # method to generate the code and compile it           
        if self.use_jit:
            # generate the code and save it in self.code, by calling get_code method from CpuReduc or GpuReduc classes :
            self.get_code(for_jit=True)
            # we execute the main dll, passing the code as argument, and the name of the low level code file to save the assembly instructions
            self.my_c_dll.Compile(create_string_buffer(self.low_level_code_file), create_string_buffer(self.code.encode('utf-8')))
        else:
            # generate the code and save it in self.code, by calling get_code method from CpuReduc or GpuReduc classes :
            self.get_code(for_jit=False)
            # write the code in the source file
            self.write_code()
            # call the compilation command
            os.system(self.compile_command)
        # retreive some parameters that will be saved into info_file.
        self.tagI = self.red_formula.tagI
        self.dim = self.red_formula.dim
        self.dimy = self.varloader.dimy
            
    def get_dll_and_params(self):
        # main method of the class : it compiles - if needed - the code and returns the name of the dll to be run for 
        # performing the reduction, e.g. 7b9a611f7e.so, or in the case of JIT compilation, the name of the main KeOps dll,
        # and the name of the assembly code file.
        file_to_check = self.low_level_code_file if self.use_jit else self.dllname
        if not os.path.exists(file_to_check):
            print("[KeOps] Compiling formula :", self.red_formula, "...", flush=True, end="")
            start = time.time()
            self.compile_code()
            self.save_info()
            elapsed = time.time()-start
            print("Done ({:.2f} s)".format(elapsed))
        else:
            self.read_info()
        if self.use_jit:
            return dict(dllname=self.jit_binary, low_level_code_file=self.low_level_code_file, tagI=self.tagI, dim=self.dim, dimy=self.dimy)
        else:
            return dict(dllname=self.dllname, tagI=self.tagI, dim=self.dim)    
        
        
